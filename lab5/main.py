# Создание декоратора для мемоизации
def memoize(func):
    memo = {}  # Словарь для хранения результатов
    def helper(x):
        if x not in memo:  # Проверка на результат для данного аргумента в словаре
            memo[x] = func(x)  # Если результат не найден, вызываем исходную функцию и сохраняем результат в словаре
        return memo[x]  # Возвращаем результат из словаря
    return helper  # Возвращаем обернутую функцию

# Пример рекурсивной функции, которую мы хотим оптимизировать
@memoize #Декоратор memoize к функции fibonacci
def fibonacci(n):
    if n <= 1:  # Базовый случай: если n меньше или равно 1, возвращаем n
        return n
    else:  # Выполнение рекурсивного вызова
        return fibonacci(n-1) + fibonacci(n-2)  # Складываем результаты

# Пример использования
print(fibonacci(5))  # Вызываем функцию fibonacci с аргументом 5 и печатаем результат
